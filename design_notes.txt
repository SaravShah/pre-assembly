To-do summary:

    - specs
    - YAML instead of XML during pre-assembly.
    - workflow
    - misc pre-assemly
    - AssemblyItem
    - common-assembly robots

Download:

    - Receive the bundle of material (e.g. REVS hard drive).
    - Copy the bundle to a prep area on the thumper staging machine.
    - Launch the automated assembly process.


Assembly preparation:

    # Load information from the data provider.
    - Manifest.
    - Expected checksum metadata.

    For each digital object:

        - Register the object and acquire a druid.
        - Move object to thumper staging directory (eg, dpgthumper-staging/PROJECT/DRUID_TREE).
        - Generate a content_metadata.yml.
        - Generate a descriptive_metadata.yml to store provider-supplied information.
        - Initialize the object's workflow in DOR.


Assembly robots:

    # ROBOT.
    - Generate content_metadata.xml from content_metadata.yml.

    # ROBOT.
    - Compute checksums for TIF.
    - Store that info in content_metadata.xml.

    # ROBOT.
    - Compare actual checksums against expected checksums for TIF.

    # ROBOT.
    - Compute image attributes for TIF: exif and related info (including cropped).
    - Store that info in content_metadata.xml.

    # ROBOT.
    - Create JP2

    # ROBOT.
    - Compute image attributes for JP2: exif and related info.
    - Store that info in content_metadata.xml.

    # ROBOT.
    - Compute checksums for JP2.
    - Store that info in content_metadata.xml.

    # ROBOT.
    - Generate descriptive metadata from one of the source listed below. This approach
      relieves common-accessioning of using outside sources for content metadata.
        - descriptive_metadata.yml
        - mdtoolkit
        - symphony

    # ROBOT.
    - Make REST calls to dor-services to initiate common-accessioning.
    - See https://consul.stanford.edu/display/chimera/REST+mappings+for+dor-services+gem
        initialize_workspace
        initiate_apo_workflow


==================================================

Needed Git projects:

    (1) AssemblyItem

        # Mimic dor-services, using branch origin/feature/object-refactor.

        module Dor

            class AssemblyItem < Dor::Item
                include Checksumable
                include Exifable

    (2) Assembly
    
        # Mimic common-accessioning.

        module Assembly
          
          class Checksum < LyberCore::Robots::Robot

            def initialize(opts = {})
              super('assemblyWF', 'checksum', opts)
            end

            def process_item(work_item)
              obj = Dor::AssemblyItem.load_instance(work_item.druid)
              obj.checksum
            end
            

==================================================

Misc notes on existing code:

    Required parameters
        tiff file name

    Image attributes: computed, or supplied optionally (*)
        exif information
        jp2 file name (*)
        allow overwrite (*)
        output profile (*)
        input profile

    temp tiff file name
        pixdem
        layers

        publish (*)
        preserve (*)
        shelve (*)
        content label (*)
        file size
        md5 checksum
        sha1 checksum
        format

    Sanity checks
        tiff file exists
        mimetype == tiff
        jp2 file does not exist (unless overwrite requested)
        output profile file exists

        image exists

    Constants
        output profile file name
        input profile file name

        content type description
        cropped

    System calls
        should check return values
        need a mechanism by bypassing/mocking
        is the generic rescue block needed or useful?
        See the systemu gem.


==================================================

cd ROBOT_ROOT
ROBOT_ENVIRONMENT=development bin/run_robot start assemblyWF:create-jp2 assemblyWF:foo-bar ...
