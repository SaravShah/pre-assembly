==Pre-assembly

This is a Ruby implementation of services needed to prepare objects to be
assembled and then accessioned in SULAIR digital library.


==Running

1. Gather information about your project, including:
	a. The location on disk of the materials.  You will need read access to this location from the servers you will be accessioning in (e.g. test and production).
	b. Whether the objects are already registered or not.
	c. Whether you will be flattening the folder structure of each object when accessioning (e.g. discarding any folder structure provided to you in each object).
	d. The druid of the project's APO.
	e. The druid of any set object you will be associating your objects with (if any).
	f. If you're objects are not yet registered and you have a manifest file in CSV format, make sure you have columns for source id, filename, and label.  See config/projects/manifest_template/TEMPLATE_manifest.csv for an example manifest.  See the "manifest" section below for more information.
	g. If you are using a manifest file in CSV format and want to create descriptive metadata, create a MODs template.  See the "descriptive metadata" section below for more details.
	
2. Create a project-configuration YAML file using the data you gathered above.  Store this file in a location where it can be accessed by the server (test or production).  You should create a YAML file for each environment specifying the parameters as appropriate.  Use the convention of "projectname_environment.yaml", e.g. "revs_test.yaml".  

Store this at the root of your bundle directory, or create a new project folder, place your YAML file into it and then place your bundle directory into your new project folder.

Example:

Your content is on /thumpers/dpgthumper-staing/Hummel
Create a YAML file at /thumpers/dpgthumper-staging/Hummel/hummel_test.yaml
More your content (if you can) into /thumpers/dpgthumper-staging/Hummel/content

If you cannot move your content, be sure your YAML bundle discovery glob and/or regex are specific enough to correctly ignore your YAML file during discovery.  Or, alternatively, place your YAML file in some other location.

   See config/projects/TEMPLATE.yaml for a documented example.  
   See config/projects/local_dev_revs.yaml for an example with no comments.

3. You will benefit from running some objects in a local or test environment.  If your objects are already registered, this may require pre-registering a sample set in test as well as production using the same DRUIDs that are identified with your content.

4. Make sure you have an APO for your object, and that the administrativeMetadata data stream has the <assemblyWF> defined in it.  If it does not, go to https://consul.stanford.edu/display/APO/Home and find the "Current FoXML APO template" link at the bottom of the page.  Download and open the template, find the <assembly> node and copy it.  Go to Fedora admin for each relevant environment (test/production) and this node to the administrativeMetadata stream.  If you don't have this workflow defined in your APO, then the assembly robots will never operate and accessioning will not operate.

5. Check to make sure each file in a given object has unique filenames if you are flattening each object's folder structure during pre-assembly (e.g. each object has images in a '00' and '05' directory, but you don't want to retain those folders when accessioning).  To do this:

   bin/object_filenames_unique YAML_FILE

You will see a report of any objects which have duplicate filenames, or a message if none are found.  You must resolve the duplicate filenames if you intend to flatten the folder structure when accessioning.

6. To run pre-assembly locally:

    # Normal run.  Will restart and crete a new log file, overwriting any existing log file for that project.
    bin/pre-assemble YAML_FILE

    # Run in resume mode, which will automatically pick up where left off based on the log file.
    bin/pre-assemble YAML_FILE --resume

7. Running in the production environment:

    - Navigate to the production box, in the pre-assembly area.
    - Set the ROBOT_ENVIRONMENT.
    - Run pre-assembly with nohup and in the background (&).
    - Optionally, include the --resume option.
	
	See the example below:

    ssh lyberadmin@sul-lyberservices-prod.stanford.edu
    cd /home/lyberadmin/pre-assembly/current
    ROBOT_ENVIRONMENT=production nohup bin/pre-assemble YAML_FILE &

    # Various ways to monitor progress:
    1. The workflow grid in Argo, using your project tag to filter.
    2. grep pid PROGRESS_LOG          # Using the filename defined in YAML progress_log_file.
    3. tail -999f log/production.log  # Detailed logging info for the pre-assembly project itself.
    4. tail -999f nohup.out           # Errors, etc from unix output.


==Manifests

Manifests are a way of indicating which objects you will be accessioning.  A manifest file is a CSV, UTF-8 encoded file and currently only works for projects that have a single file (e.g. image) per object, since each row in the manifest will become an object.  

There are three required columns in the manifest:

sourceid
filename
label

The first line of the manifest is a header and specifies the column names.  These columns are used to register objects and indicate which file goes with the object.  The filename is relative to the manifest file itself.  You can have additional columns in your
manifest which can be used to create descriptive metadata for each object.  See the section below for more details.

A sample manifest file is located in config/projects/manifest_template/TEMPLATE_manifest.csv for an example.  

==Descriptive Metadata

If descriptive metadata is supplied in a source known to common accessioning (currently MDToolkit or Symphony), then no action is required during pre-assembly.

If you are supplying a manifest file instead of using object discovery via file system crawling, then you can also create descriptive metadata MODs file for each object using content supplied in additional columns in the manifest.  By specifing a template XML MODS file in your YAML configuration, you can tell pre-assembly to generate a MODs file per object called "descriptiveMetadata.xml" and stage this file for accessioning.  The MODs file is generated by taking the XML template you supply, and filling in any [[FIELD]] values in the template with the corresponding column from the manifest that is called FIELD.

For example, if your template has

<mods><title>[[description]]</title></mods>

and you have a column called "description" in your manifest with a value of "picture of me", you will get that value filled into your template for that object, like

<mods><title>picture of me</title></mods>

In addition, the entire MODs template is passed through an ERB parser each time, allowing you to place complex Ruby code into the template using the standard <%= %> syntax.  If you do this, you will have access to a special local hash called 'manifest_row', which you gives you access to the manifest columns for that object, keyed off the column names.  For example:

 <mods><title><%= manifest_row[:description] %></title></mods>
 
 will provide the same output as the previous example.  A full example of a MODs template is provided at config/projects/manifest_template/TEMPLATE_mods.xml


==Deployment

See Capfile.

==Setting up code for local development

    # Clone project.
    git clone `whoami`@corn.stanford.edu:/afs/ir/dev/dlss/git/lyberteam/pre-assembly.git
    cd pre-assembly

    # Set up some stuff not stored in Git.
    mkdir doc log pkg tmp
    RCONF='lyberadmin@lyberservices-dev.stanford.edu:/home/lyberadmin/pre-assembly/config'
    scp -r $RCONF/certs $RCONF/environments config

    # Get needed gems.
    bundle install

    # Confirm that it's working.  Note that for integration tests to work, you will need to be on the Stanford network and kerberos         # authenticated
    bin/run_all_tests 


==Running tests

For local testing, it's easiest to put this in your bash profile:

	export ROBOT_ENVIRONMENT=local

Running tests:

    # All tests.
    bin/run_all_tests

    # Unit tests and integration tests separately.
    bundle exec rspec spec
    bundle exec rspec integration
